name: PS1 → EXE (Windows Release, start.exe only)

on:
  push:
    branches: [ "master", "main" ]
    paths:
      - "scripts/start.ps1"
      - ".github/workflows/ps1-to-exe-win-release.yml"
  workflow_dispatch:
    inputs:
      gui:
        description: Build as GUI app (no console)
        type: choice
        options: ["false","true"]
        default: "false"
      require_admin:
        description: EXE requires elevation (UAC)
        type: choice
        options: ["false","true"]
        default: "false"
      product_name:
        description: File/Product metadata
        default: WinUtil
      company_name:
        description: Company metadata
        default: "Anthony Walters"
      file_version:
        description: File version (a.b.c.d)
        default: 1.0.0.0
      icon_path:
        description: ico path (repo-relative)
        default: "assets/winutil.ico"

permissions:
  contents: write
  actions: read

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve tag/version
        id: meta
        shell: pwsh
        run: |
          $shaShort = '${{ github.sha }}'.Substring(0,7)
          $run = '${{ github.run_number }}'
          $tag = "ps1-exe-$run-$shaShort"
          $verIn = '${{ github.event.inputs.file_version }}'
          $ver = if ($verIn) { $verIn } else { '1.0.0.0' }
          "tag=$tag"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "version=$ver" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          Write-Host "Tag: $tag  Version: $ver"

      - name: Install PS2EXE
        shell: pwsh
        run: |
          Set-ExecutionPolicy -Scope Process Bypass -Force
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          Install-Module ps2exe -Scope CurrentUser -Force -AllowClobber
          Import-Module ps2exe -Force

      - name: Build start.exe
        shell: pwsh
        env:
          GUI: ${{ github.event.inputs.gui }}
          REQUIRE_ADMIN: ${{ github.event.inputs.require_admin }}
          PRODUCT_NAME: ${{ github.event.inputs.product_name }}
          COMPANY_NAME: ${{ github.event.inputs.company_name }}
          FILE_VERSION: ${{ steps.meta.outputs.version }}
          ICON_PATH: assets/winutil.ico
        run: |
          $ErrorActionPreference = 'Stop'

          $entry = Join-Path $PWD 'scripts/start.ps1'
          if (-not (Test-Path $entry)) {
            Write-Error "Entry script not found at $entry"
            exit 1
          }

          $outDir = Join-Path $PWD 'dist'
          if (Test-Path $outDir) { Remove-Item $outDir -Recurse -Force }
          New-Item -ItemType Directory -Path $outDir | Out-Null

          $out  = Join-Path $outDir 'start.exe'
          $meta = @{
            Title        = if ($env:PRODUCT_NAME) { $env:PRODUCT_NAME } else { 'start' }
            Product      = if ($env:PRODUCT_NAME) { $env:PRODUCT_NAME } else { 'start' }
            Company      = $env:COMPANY_NAME
            FileVersion  = $env:FILE_VERSION   # mapped to -Version
            NoConsole    = ($env:GUI -eq 'true')
            RequireAdmin = ($env:REQUIRE_ADMIN -eq 'true')
            IconFile     = $null
          }

          # Optional per-script override at scripts/start.ps1.json
          $jsonPath = "$entry.json"
          if (Test-Path $jsonPath) {
            try {
              $j = Get-Content $jsonPath -Raw | ConvertFrom-Json
              foreach ($k in 'Title','Product','Company','FileVersion','Version') {
                if ($j.$k) { $meta[$k] = [string]$j.$k }
              }
              if ($j.NoConsole -ne $null)    { $meta['NoConsole']    = [bool]$j.NoConsole }
              if ($j.RequireAdmin -ne $null) { $meta['RequireAdmin'] = [bool]$j.RequireAdmin }
              if ($j.IconFile)               { $env:ICON_PATH = [string]$j.IconFile }
            } catch { Write-Warning "Failed to parse $jsonPath; using defaults." }
          }

          if ($env:ICON_PATH -and (Test-Path $env:ICON_PATH)) {
            $meta['IconFile'] = (Resolve-Path $env:ICON_PATH).Path
          }

          $params = @{
            InputFile  = $entry
            OutputFile = $out
            Title      = $meta.Title
            Product    = $meta.Product
            Company    = $meta.Company
            Version    = ($meta.FileVersion ?? $meta.Version ?? '1.0.0.0')  # ps2exe expects -Version
          }
          if ($meta.NoConsole)    { $params['NoConsole']    = $true }
          if ($meta.RequireAdmin) { $params['RequireAdmin'] = $true }
          if ($meta.IconFile)     { $params['IconFile']     = $meta.IconFile }

          Write-Host "Building $entry → $out"
          Invoke-ps2exe @params

          if (-not (Test-Path $out)) { Write-Error "start.exe not produced"; exit 1 }
          Get-ChildItem $outDir -File | Format-Table -AutoSize

      - name: Upload artifact (CI)
        uses: actions/upload-artifact@v4
        with:
          name: start-exe
          path: dist/start.exe
          if-no-files-found: error

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name:  ${{ steps.meta.outputs.tag }}
          release_name: "PS1→EXE Windows (${{ steps.meta.outputs.tag }})"
          draft: false
          prerelease: false

      - name: Upload start.exe to Release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: dist/start.exe
          asset_name: start.exe
          asset_content_type: application/octet-stream
